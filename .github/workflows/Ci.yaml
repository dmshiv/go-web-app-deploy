# CI/CD Pipeline for Go Web Application
# This workflow automates: build → test → dockerize → deploy to Kubernetes

name: CI

# Trigger: Runs when code is pushed to master branch
# Ignores: Changes to Readme.md or Helm charts (those don't affect the app)
on:
  push:
    branches:
      - master        
    paths-ignore:
      - 'Readme.md'
      - 'Helm/**'

jobs:
  # ============================================================================
  # JOB 1: BUILD AND TEST
  # Purpose: Compile the Go application and run unit tests to ensure code quality
  # ============================================================================
  build:
    runs-on: ubuntu-latest  # Uses GitHub's Ubuntu runner
    steps:
      # Step 1: Download the code from GitHub to the runner
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Install Go version 1.21 on the runner
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      # Step 3: Build the Go application from the go-web-app folder
      # This compiles the code and checks for compilation errors
      - name: Build the Go application
        working-directory: ./go-web-app
        run: go build -v ./...

      # Step 4: Run unit tests to verify the code works correctly
      # If tests fail, the pipeline stops here
      - name: Run tests
        working-directory: ./go-web-app
        run: go test -v ./...

  # ============================================================================
  # JOB 2: CODE QUALITY (placeholder for future linting/scanning)
  # Purpose: Can add code quality checks like linting, security scans, etc.
  # ============================================================================
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      # TODO: Add golangci-lint or other code quality tools here

  # ============================================================================
  # JOB 3: DOCKER BUILD AND PUSH
  # Purpose: Create a Docker image and push it to DockerHub
  # Depends on: build job must pass first
  # ============================================================================
  push:
    runs-on: ubuntu-latest
    needs: build  # Only runs if build job succeeds
    steps:
      # Step 1: Download the code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Set up Docker Buildx (advanced Docker builder)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      # Step 3: Login to DockerHub using credentials stored in GitHub Secrets
      # Secrets keep your username and password secure
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}  # Your DockerHub username
          password: ${{ secrets.DOCKERHUB_TOKEN }}      # Your DockerHub access token

      # Step 4: Build Docker image and push to DockerHub
      # Tags the image with a unique GitHub run ID (e.g., avatar100/go-web-app:123456)
      # This ensures each build creates a unique, traceable image
      - name: Build and Push action
        uses: docker/build-push-action@v6
        with:
          context: ./go-web-app              # Build from go-web-app directory
          file: ./go-web-app/Dockerfile       # Use this Dockerfile
          push: true                          # Push to DockerHub after building
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/go-web-app:${{ github.run_id }}

  # ============================================================================
  # JOB 4: UPDATE HELM CHART FOR KUBERNETES DEPLOYMENT
  # Purpose: Automatically update the Helm chart with the new Docker image tag
  # Depends on: push job must complete first (image must be on DockerHub)
  # Why: This enables GitOps - the Helm chart always points to the latest image
  # ============================================================================
  update-newtag-in-helm-chart:
    runs-on: ubuntu-latest
    needs: push  # Only runs after Docker image is pushed
    steps:
      # Step 1: Checkout code with a personal access token
      # TOKEN allows the workflow to push changes back to the repo
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.TOKEN }}

      # Step 2: Update the image tag in Helm values.yaml
      # Replaces the old tag with the new GitHub run ID
      # Example: Changes "tag: 12345" to "tag: 67890"
      - name: Update tag in Helm chart
        run: |
          sed -i 's/tag: .*/tag: "${{ github.run_id }}"/' Helm/go-web-app-chart/values.yaml

      # Step 3: Commit and push the updated values.yaml back to GitHub
      # This creates a new commit with the updated image tag
      # ArgoCD or other GitOps tools can then detect this change and deploy
      - name: Commit and push changes
        run: |
          git config --global user.email "dmshivku@gmail.com"
          git config --global user.name "dmshivku"
          git add Helm/go-web-app-chart/values.yaml
          git commit -m "Update tag in Helm chart"
          git push


# Real-World Example:
# You fix a bug and push code to GitHub
# GitHub Actions compiles and tests your code (2 minutes)
# If tests pass, it builds a Docker image: go-web-app:789012
# Image gets uploaded to DockerHub
# Helm chart gets updated: "Use image 789012"
# ArgoCD (or another tool) sees the change and deploys to Kubernetes
# Your app is now live with the bug fix!
        
